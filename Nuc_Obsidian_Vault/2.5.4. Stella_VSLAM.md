
# 1. Sorry, but ChatGPT Chat

please help me install Stella_vslam for ros. please look at the following 2 websites: https://github.com/stella-cv/stella_vslam https://github.com/stella-cv/stella_vslam_ros/tree/ros2 please help me install and run this stella_vslam package. My ros 2 workspace is called ros2_ws

Reasoned for 15 seconds

Below is a step-by-step guide to install and run **stella_vslam** and **stella_vslam_ros** on a ROS 2 setup (e.g., Ubuntu 22.04 with ROS 2 Humble). These instructions summarize and combine the official guides from the two repositories:

- [stella_vslam GitHub](https://github.com/stella-cv/stella_vslam)
- [stella_vslam_ros (ros2 branch)](https://github.com/stella-cv/stella_vslam_ros/tree/ros2)

> **Note**:
> 
> 1. The instructions here are tailored to Ubuntu 22.04 + ROS 2 Humble, but they are largely similar for other Ubuntu/ROS 2 versions (you may have to adapt package names).
> 2. If you already have a working ROS 2 environment in `~/ros2_ws`, you can re-use it. Otherwise, adapt the folder names below to match your workspace layout.

---

## 1. Install ROS 2

If you have not already installed ROS 2 Humble (on Ubuntu 22.04), follow the official installation instructions. You should have a fully sourced and working ROS 2 environment. For example:

bash

CopyEdit

`# Source the ROS 2 setup file for Humble source /opt/ros/humble/setup.bash`

---

## 2. Install System Dependencies

stella_vslam has several dependencies, and so does stella_vslam_ros. Below is a consolidated list of packages needed:

bash

CopyEdit

`sudo apt update && sudo apt install -y \     cmake git build-essential \     autoconf autogen libtool pkg-config \     libgoogle-glog-dev libatlas-base-dev libsuitesparse-dev \     libyaml-cpp-dev \     ros-humble-cv-bridge \     ros-humble-image-transport \     ros-humble-image-geometry`

### (Optional) Pangolin

stella_vslam can use [Pangolin](https://github.com/stevenlovegrove/Pangolin) for visualizing frames and maps. If you want this visualization feature, you need Pangolin installed. There is no official `apt` package for Pangolin on Ubuntu, so you can build it from source or skip it if you do not need the visualization.

**To build Pangolin from source**:

bash

CopyEdit

`# Install prerequisites sudo apt install -y libglew-dev libboost-dev libxkbcommon-dev  # Build Pangolin (from GitHub source) cd ~ git clone https://github.com/stevenlovegrove/Pangolin.git cd Pangolin mkdir build && cd build cmake .. make -j$(nproc) sudo make install`

---

## 3. Create a ROS 2 Workspace

If you do not already have a workspace (e.g. `~/ros2_ws`), create one:

bash

CopyEdit

`mkdir -p ~/ros2_ws/src cd ~/ros2_ws`

Make sure you have sourced ROS 2:

bash

CopyEdit

`source /opt/ros/humble/setup.bash`

---

## 4. Clone stella_vslam and stella_vslam_ros (ros2 branch)

Inside your workspace’s `src` folder:

bash

CopyEdit

``cd ~/ros2_ws/src  # Clone stella_vslam (master/main branch is typically fine) git clone https://github.com/stella-cv/stella_vslam.git  # Clone stella_vslam_ros (use the `ros2` branch!) git clone --branch ros2 https://github.com/stella-cv/stella_vslam_ros.git``

You should now have two folders:

bash

CopyEdit

`~/ros2_ws/src/stella_vslam ~/ros2_ws/src/stella_vslam_ros`

---

## 5. Build with colcon

Go to the root of your workspace and build everything:

bash

CopyEdit

`cd ~/ros2_ws colcon build --symlink-install`

If all goes well, the build should finish without errors.

Finally, **source** the newly built packages:

bash

CopyEdit

`source ~/ros2_ws/install/setup.bash`

> **Tip**: Add the above line to your `~/.bashrc` (or your preferred shell config) so that the workspace environment is automatically sourced when you open a new terminal.

---

## 6. Running stella_vslam_ros

### 6.1 Launch a Camera Stream (or a Bag File)

To test SLAM, you need an image topic and corresponding camera info topic. Typically:

- A **USB camera** or other camera driver can be used. For example, if using a standard ROS 2 camera node, you might have topics like `/camera/image_raw` and `/camera/camera_info`.
- Alternatively, you can play a ROS bag file that publishes these topics.

Example: if you have a camera node in another package:

bash

CopyEdit

`# Terminal 1 source ~/ros2_ws/install/setup.bash ros2 run my_camera_pkg my_camera_node`

Or if using a ROS bag:

bash

CopyEdit

`# Terminal 1 source ~/ros2_ws/install/setup.bash ros2 bag play my_dataset.bag`

Make sure you know the exact topics for the image and camera info.

### 6.2 Launch stella_vslam_ros

In a **new terminal** (with the workspace sourced), you can run stella_vslam_ros and pass in relevant parameters. The **ROS 2** stella_vslam node is typically launched via:

bash

CopyEdit

`source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros stella_vslam_node --ros-args \     -p vocab_file:="<path_to_orb_vocab>.yaml" \     -p config_file:="<path_to_camera_config>.yaml" \     -r /camera/color/image_raw:=/your_image_topic \     -r /camera/color/camera_info:=/your_camera_info_topic`

where:

- `vocab_file` is the path to your ORB vocabulary file (e.g. `orb_vocab.dbow2` or a `.yaml` from the [ORBVocabulary repo](https://github.com/raulmur/ORB_SLAM2/tree/master/Vocabulary)).
- `config_file` is your stella_vslam camera configuration YAML (intrinsic parameters, etc.). You can find sample config files in `stella_vslam/example`.

For example:

bash

CopyEdit

`ros2 run stella_vslam_ros stella_vslam_node --ros-args \     -p vocab_file:="$HOME/ros2_ws/src/stella_vslam/orb_vocab/orb_vocab.dbow2" \     -p config_file:="$HOME/ros2_ws/src/stella_vslam/example/settings/EuRoC_mono.yaml" \     -r /camera/color/image_raw:=/camera/image_raw \     -r /camera/color/camera_info:=/camera/camera_info`

You should see log output from stella_vslam, and if Pangolin is installed (and the config is set to use it), a Pangolin window will open showing the tracking status and map.

---

## 7. Additional Notes

1. **Configuration Files**  
    Make sure your camera’s resolution, focal length, and other intrinsic parameters match your real camera or dataset. The sample configs in `stella_vslam/example/settings` or the `stella_vslam_ros/config` folder can be used as a starting point.
    
2. **ORB Vocabulary**  
    stella_vslam typically uses an ORB vocabulary file for place recognition. You can download one from the official ORB_SLAM2 repository or stella_vslam’s own releases. Place it somewhere accessible, then set the `vocab_file` parameter.
    
3. **Using Pangolin**  
    If you installed Pangolin, then you can enable the viewer by adding `-p enable_pangolin_viewer:=True` (or setting that in your config). If Pangolin is not installed or you have issues, run with `-p enable_pangolin_viewer:=False`.
    
4. **Launching via Launch Files**  
    For more complex setups, you can create a `.launch.py` in the stella_vslam_ros package or your own package to configure parameters and topic remappings. That is often the best approach for production.
    

---

## Quick Reference

1. **Install prerequisites**
    
    bash
    
    CopyEdit
    
    `sudo apt update && sudo apt install -y \     cmake git build-essential \     autoconf autogen libtool pkg-config \     libgoogle-glog-dev libatlas-base-dev libsuitesparse-dev \     libyaml-cpp-dev \     ros-humble-cv-bridge \     ros-humble-image-transport \     ros-humble-image-geometry`
    
    _(Also build/install Pangolin if desired.)_
    
2. **Create and source your ROS 2 workspace**
    
    bash
    
    CopyEdit
    
    `mkdir -p ~/ros2_ws/src cd ~/ros2_ws source /opt/ros/humble/setup.bash`
    
3. **Clone the repositories**
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws/src git clone https://github.com/stella-cv/stella_vslam.git git clone --branch ros2 https://github.com/stella-cv/stella_vslam_ros.git`
    
4. **Build**
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws colcon build --symlink-install source ~/ros2_ws/install/setup.bash`
    
5. **Run**  
    In one terminal, run a camera driver or bag:
    
    bash
    
    CopyEdit
    
    `ros2 bag play <my_dataset.bag>`
    
    In another terminal, run stella_vslam_ros:
    
    bash
    
    CopyEdit
    
    `ros2 run stella_vslam_ros stella_vslam_node --ros-args \     -p vocab_file:="path/to/orb_vocab.dbow2" \     -p config_file:="path/to/camera.yaml" \     -r /camera/color/image_raw:=/camera/image_raw \     -r /camera/color/camera_info:=/camera/camera_info`
    

If everything is set up properly, you’ll see SLAM tracking and map creation in real time (with or without the Pangolin viewer, depending on your configuration).

---

### That’s it!

You have now installed **stella_vslam** and **stella_vslam_ros** in your ROS 2 workspace (`ros2_ws`). From here, you can customize configurations, launch files, and integrate with your own sensor drivers or datasets. Happy SLAMming!

o1

##### You said:

I found the folowing instructions on the ros2 page, how do tey change the installation process: Install instruction stella_vslam_ros uses submodules. Clone it with git clone --recursive or download submodules with git submodule update --init --recursive.

Reasoned for a few seconds

**Short Answer**  
They mean that **stella_vslam_ros** has some code in submodules, so you need to ensure those submodules are downloaded when you clone it. You can either:

1. Clone with `--recursive`:
    
    bash
    
    CopyEdit
    
    `git clone --branch ros2 --recursive https://github.com/stella-cv/stella_vslam_ros.git`
    
2. Or, if you already cloned without `--recursive`, then run:
    
    bash
    
    CopyEdit
    
    `cd stella_vslam_ros git submodule update --init --recursive`
    

Either method will pull down any extra code in the stella_vslam_ros repository’s submodules, which the package needs to build and run properly.

---

## Details

When a Git repository uses submodules, it references other Git repos (or parts of them) inside itself. This means that a normal `git clone` will not automatically fetch the submodule contents—only a “pointer” to them. Using `--recursive` (or running `git submodule update --init --recursive` afterward) tells Git to fetch and check out those submodule repositories as well.

In practical terms:

1. **If you originally followed instructions without mentioning submodules**, your stella_vslam_ros folder might be missing submodule content.
    
2. **If you use the `--recursive` flag** when cloning, Git automatically fetches submodules, so you won’t need a second step.
    
3. **If you already cloned without `--recursive`**, navigate into the `stella_vslam_ros` folder, and run:
    
    bash
    
    CopyEdit
    
    `git submodule update --init --recursive`
    
    That command pulls down the missing submodule repositories.
    

After making sure the submodules are downloaded, **everything else** in the build/install process remains **the same**:

- You still install the same apt dependencies.
- You still place the stella_vslam repositories in your `ros2_ws/src`.
- You still build with `colcon build`.

The key difference is just ensuring that the submodules are present before you run the build.

o1

##### You said:

can I run stellaslam live, using my oakd pro w camera topics?

Reasoned for 10 seconds

**Short Answer:**  
Yes, you can run _stella_vslam_ (and stella_vslam_ros) in real time using topics from an OAK-D Pro camera, as long as you have a ROS driver that publishes the correct image and camera info topics. From stella_vslam’s perspective, it simply subscribes to one or more image topics (and their corresponding `camera_info`). Whether you use mono, stereo, or RGB-D modes depends on how you configure and publish data from the OAK-D Pro.

Below is an outline of what you need to do.

---

## 1. Install the OAK-D Pro (DepthAI) ROS Driver

There are a couple of ROS 2 drivers for Luxonis OAK devices (e.g., the [Luxonis/depthai-ros](https://github.com/luxonis/depthai-ros) repository). You will need:

1. A node that **publishes** the OAK-D Pro camera frames (`image_raw`)
2. A node that also **publishes** the corresponding `camera_info` topic (with the intrinsics)

For example, if using `depthai-ros`, you might have something like:

bash

CopyEdit

`ros2 run depthai_ros_driver depthai_ros_driver_node --ros-args \     -p camera_name:=oak \     -p usb_speed:="SUPER" \     ...`

Check the driver’s documentation for how to configure the camera (mono, stereo, color, IR, etc.) and for the exact ROS topics it publishes. Common topics might look like:

- `/oak/rgb/image_raw`
- `/oak/rgb/camera_info`
- `/oak/left/image_raw`
- `/oak/left/camera_info`
- `/oak/right/image_raw`
- `/oak/right/camera_info`
- etc.

---

## 2. Decide on Monocular, Stereo, or RGB-D Operation

### Monocular

If you only want to run a _single camera_ SLAM (e.g., color camera stream from the OAK-D Pro), then you will configure stella_vslam with a **mono** config file.

- Typically, you would have `/oak/rgb/image_raw` and `/oak/rgb/camera_info`.
- In stella_vslam’s config `.yaml`, set `Camera.name:`, `Camera.fx:`, `Camera.fy:`, `Camera.cx:`, `Camera.cy:` to match your OAK-D Pro intrinsics.
- Or, if the driver publishes correct `camera_info`, stella_vslam_ros can read them from that ROS topic.

### Stereo

If you want _stereo SLAM_, you can use the OAK-D Pro’s left and right cameras. Then you’ll need:

- `/oak/left/image_raw`, `/oak/left/camera_info`
- `/oak/right/image_raw`, `/oak/right/camera_info`
- A stella_vslam **stereo** config file with intrinsics/extrinsics for both cameras.
- Then you would run stella_vslam_ros accordingly, remapping the left and right topics to match what the OAK driver publishes.

### RGB-D

If you want an **RGB-D** approach (using depth from the device), stella_vslam supports an RGB-D mode as well. You’ll need a config file for RGB-D, plus topics for the color image and a corresponding depth image. In that case, your DepthAI driver must publish a `/depth` topic (or something similar) plus the color image.

---

## 3. Provide the Right Config to stella_vslam_ros

When launching stella_vslam_ros, you will specify:

1. **ORB Vocabulary file** (`vocab_file`)
2. **Camera configuration file** (`config_file`) – or rely on ROS 2 parameters if set up that way.

Then you’ll **remap** the default camera topics to match what your OAK-D Pro driver is publishing:

bash

CopyEdit

`# Example for a monocular setup ros2 run stella_vslam_ros stella_vslam_node --ros-args \   -p vocab_file:="path/to/orb_vocab.dbow2" \   -p config_file:="path/to/my_oakd_monocular.yaml" \   -r /camera/color/image_raw:=/oak/rgb/image_raw \   -r /camera/color/camera_info:=/oak/rgb/camera_info`

Replace `/oak/rgb/image_raw` and `/oak/rgb/camera_info` with whatever your driver publishes. For stereo or RGB-D, you’d do something similar but remapping both left/right or color/depth topics accordingly.

---

## 4. Verify the Topics and Frame Rates

1. **Check that your OAK-D Pro driver is publishing** the topics at a reasonable frame rate (e.g., 15–30Hz).
2. **Ensure** stella_vslam’s config and the camera intrinsics match. A mismatch in intrinsics can degrade SLAM performance.
3. **Confirm that stella_vslam_ros** is actually receiving images by looking at the node’s console output or by running:
    
    bash
    
    CopyEdit
    
    `ros2 topic list ros2 topic echo /oak/rgb/camera_info ...`
    

---

## 5. (Optional) Visualization with Pangolin

If you have [Pangolin installed](https://github.com/stevenlovegrove/Pangolin) and you enable the Pangolin viewer in your stella_vslam config (`enable_pangolin_viewer:=True`), you’ll see a live 3D visualization of the map. You can also disable Pangolin if you only need the SLAM data without visualization.

---

### That’s it!

Yes, _stella_vslam_ can definitely run in real time with an OAK-D Pro (or any other camera) as long as the camera topics (and camera info) are published to ROS. Just ensure that:

1. You have the OAK-D Pro driver set up and running in ROS 2.
2. You configure stella_vslam_ros with the correct topics and a matching camera configuration.

Once you launch both, you should see live SLAM from your OAK-D Pro camera feed.

o1

##### You said:

when trying to colcon build stella_vslam, I get the following error: colcon build --packages-select stella_vslam [0.367s] WARNING:colcon.colcon_core.package_selection:Some selected packages are already built in one or more underlay workspaces: 'stella_vslam' is in: /home/nico/ros2_ws/install/stella_vslam If a package in a merged underlay workspace is overridden and it installs headers, then all packages in the overlay must sort their include directories by workspace order. Failure to do so may result in build failures or undefined behavior at run time. If the overridden package is used by another package in any underlay, then the overriding package in the overlay must be API and ABI compatible or undefined behavior at run time may occur. If you understand the risks and want to override a package anyways, add the following to the command line: --allow-overriding stella_vslam This may be promoted to an error in a future release of colcon-override-check. Starting >>> stella_vslam --- stderr: stella_vslam CMake Deprecation Warning at CMakeLists.txt:14 (cmake_policy): The OLD behavior for policy CMP0074 will be removed from a future version of CMake. The cmake-policies(7) manual explains that the OLD behaviors of all policies are deprecated and that a policy should be set to OLD only under specific short-term circumstances. Projects should be ported to the NEW behavior and not rely on setting a policy to OLD. CMake Error at src/stella_vslam/CMakeLists.txt:13 (find_package): By not providing "Findg2o.cmake" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by "g2o", but CMake did not find one. Could not find a package configuration file provided by "g2o" with any of the following names: g2oConfig.cmake g2o-config.cmake Add the installation prefix of "g2o" to CMAKE_PREFIX_PATH or set "g2o_DIR" to a directory containing one of the above files. If "g2o" provides a separate development package or SDK, be sure it has been installed. --- Failed <<< stella_vslam [0.11s, exited with code 1] Summary: 0 packages finished [0.36s] 1 package failed: stella_vslam 1 package had stderr output: stella_vslam

Reasoned for 4 seconds

You’re missing the **g2o** library dependency. The error:

kotlin

CopyEdit

`Could not find a package configuration file provided by "g2o"`

means that CMake is looking for g2o’s CMake config files (`g2oConfig.cmake` or `g2o-config.cmake`) but cannot find them. stella_vslam uses g2o internally, so you must install its development files before building.

Below are two main ways to fix this.

---

## 1. Install g2o via apt (simplest)

If you’re on Ubuntu (20.04, 22.04, etc.), you can usually install g2o from the official packages:

bash

CopyEdit

`sudo apt-get update sudo apt-get install libg2o-dev`

Then rebuild:

bash

CopyEdit

`cd ~/ros2_ws colcon build --packages-select stella_vslam --allow-overriding stella_vslam`

> **Note**:
> 
> - The `--allow-overriding stella_vslam` flag is needed because colcon sees you have already built stella_vslam in an underlay or previously in the same workspace.
> - If the build still complains about an older build in your workspace, you can either remove it or rebuild everything in a fresh workspace.

---

## 2. Build g2o from source (if the apt package is unavailable or too old)

If you need a specific version of g2o or if the apt package is missing, you can build it from source:

1. **Install dependencies**:
    
    bash
    
    CopyEdit
    
    `sudo apt-get update sudo apt-get install \     git cmake build-essential \     libeigen3-dev libsuitesparse-dev \     qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5`
    
2. **Clone and build g2o**:
    
    bash
    
    CopyEdit
    
    `cd ~ git clone https://github.com/RainerKuemmerle/g2o.git cd g2o mkdir build && cd build cmake .. -DCMAKE_BUILD_TYPE=Release make -j$(nproc) sudo make install`
    
3. **Rebuild stella_vslam**:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws colcon build --packages-select stella_vslam --allow-overriding stella_vslam`
    

---

## 3. Addressing the Colcon Warning about “Overriding stella_vslam”

You also saw this warning:

sql

CopyEdit

`Some selected packages are already built in one or more underlay workspaces:     'stella_vslam' is in: /home/nico/ros2_ws/install/stella_vslam  If a package in a merged underlay workspace is overridden … add the following:     --allow-overriding stella_vslam`

This happens if you have already built stella_vslam in the same workspace or an underlay. colcon is warning you that you’re building the same package again, which can cause conflicts.

### How to resolve it:

1. **Use the `--allow-overriding` option** (as the warning suggests). For example:
    
    bash
    
    CopyEdit
    
    `colcon build --packages-select stella_vslam --allow-overriding stella_vslam`
    
2. **Or remove the previously built stella_vslam** so that you don’t have duplicates. If you just want to rebuild cleanly, remove (or rename) the `install`, `build`, and `log` folders in your workspace, then build again:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws rm -rf build/ install/ log/ colcon build`
    

Either approach allows you to rebuild stella_vslam without the warning turning into an error.

---

## 4. Rebuild and Test

After installing g2o (and optionally removing old builds), run:

bash

CopyEdit

`cd ~/ros2_ws colcon build --symlink-install source ~/ros2_ws/install/setup.bash`

Now stella_vslam should compile successfully without the missing g2o error. Once the build completes, you can proceed to run `stella_vslam_ros` or whatever your workflow requires.

o1

##### You said:

i followed the following page: https://stella-cv.readthedocs.io/en/latest/ros2_package.html#installation with the following content: ROS2 Package Installation Prerequisites Tested for Ubuntu 22.04. Please install the following dependencies. ROS2 : humble or later. Please follow Installation of ROS2. image_tools : An optional requirement to use USB cameras. Build Instructions (If using IridescenceViewer) sudo apt install -y libglm-dev libglfw3-dev libpng-dev libjpeg-dev libeigen3-dev libboost-filesystem-dev libboost-program-options-dev git clone https://github.com/koide3/iridescence.git cd iridescence git checkout 085322e0c949f75b67d24d361784e85ad7f197ab git submodule update --init --recursive mkdir -p build cd build cmake \ -DCMAKE_BUILD_TYPE=RelWithDebInfo \ .. make -j$(($(nproc) / 2)) sudo make install (If using PangolinViewer) sudo apt install -y libglew-dev git clone https://github.com/stevenlovegrove/Pangolin.git cd Pangolin git checkout ad8b5f83 sed -i -e "193,198d" ./src/utils/file_utils.cpp mkdir -p build cd build cmake \ -DCMAKE_BUILD_TYPE=Release \ -DBUILD_EXAMPLES=OFF \ -DBUILD_PANGOLIN_DEPTHSENSE=OFF \ -DBUILD_PANGOLIN_FFMPEG=OFF \ -DBUILD_PANGOLIN_LIBDC1394=OFF \ -DBUILD_PANGOLIN_LIBJPEG=OFF \ -DBUILD_PANGOLIN_LIBOPENEXR=OFF \ -DBUILD_PANGOLIN_LIBPNG=OFF \ -DBUILD_PANGOLIN_LIBREALSENSE=OFF \ -DBUILD_PANGOLIN_LIBREALSENSE2=OFF \ -DBUILD_PANGOLIN_LIBTIFF=OFF \ -DBUILD_PANGOLIN_LIBUVC=OFF \ -DBUILD_PANGOLIN_LZ4=OFF \ -DBUILD_PANGOLIN_OPENNI=OFF \ -DBUILD_PANGOLIN_OPENNI2=OFF \ -DBUILD_PANGOLIN_PLEORA=OFF \ -DBUILD_PANGOLIN_PYTHON=OFF \ -DBUILD_PANGOLIN_TELICAM=OFF \ -DBUILD_PANGOLIN_TOON=OFF \ -DBUILD_PANGOLIN_UVC_MEDIAFOUNDATION=OFF \ -DBUILD_PANGOLIN_V4L=OFF \ -DBUILD_PANGOLIN_VIDEO=OFF \ -DBUILD_PANGOLIN_ZSTD=OFF \ -DBUILD_PYPANGOLIN_MODULE=OFF \ .. make -j$(($(nproc) / 2)) make install (If using SocketViewer) sudo apt install -y autogen autoconf libtool cd /tmp git clone https://github.com/shinsumicco/socket.io-client-cpp.git cd socket.io-client-cpp git submodule init git submodule update mkdir build && cd build cmake \ -DCMAKE_BUILD_TYPE=Release \ -DCMAKE_INSTALL_PREFIX=/usr/local \ -DBUILD_UNIT_TESTS=OFF \ .. make -j4 sudo make install sudo apt install -y libprotobuf-dev protobuf-compiler wget -q https://github.com/google/protobuf/archive/v3.6.1.tar.gz tar xf v3.6.1.tar.gz cd protobuf-3.6.1 ./autogen.sh ./configure \ --prefix=/usr/local \ --enable-static=no make -j4 sudo make install rosdep update sudo apt update mkdir -p ~/lib cd ~/lib git clone --recursive --depth 1 https://github.com/stella-cv/stella_vslam.git rosdep install -y -i --from-paths ~/lib cd ~/lib/stella_vslam mkdir -p ~/lib/stella_vslam/build cd ~/lib/stella_vslam/build source /opt/ros/${ROS_DISTRO}/setup.bash cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for IridescenceViewer cd ~/lib git clone --recursive https://github.com/stella-cv/iridescence_viewer.git mkdir -p iridescence_viewer/build cd iridescence_viewer/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for PangolinViewer cd ~/lib git clone --recursive https://github.com/stella-cv/pangolin_viewer.git mkdir -p pangolin_viewer/build cd pangolin_viewer/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for SocketViewer cd ~/lib git clone --recursive https://github.com/stella-cv/socket_publisher.git mkdir -p socket_publisher/build cd socket_publisher/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src git clone --recursive -b ros2 --depth 1 https://github.com/stella-cv/stella_vslam_ros.git cd ~/ros2_ws rosdep install -y -i --from-paths ~/ros2_ws/src --skip-keys=stella_vslam colcon build --symlink-install For using USB cam as a image source, download a repository of demos and pick image_tools module. cd ~/ros2_ws git clone https://github.com/ros2/demos.git cp -r demos/image_tools src/ rm -rf demos Examples Publisher Publish Images by a video ros2 run image_publisher image_publisher_node ./aist_living_lab_1/video.mp4 --ros-args --remap /image_raw:=/camera/image_raw Publish Images Captured by a USB Camera For using a standard USB camera for visual SLAM or localization. ros2 run image_tools cam2image Republish the ROS topic to /camera/image_raw. ros2 run image_transport republish \ raw in:=image raw out:=/camera/image_raw Subscriber Subscribers continually receive images. Please execute one of the following command snippets in the new terminal. Note Option arguments are the same as the examples of stella_vslam. Tracking and Mapping We provide an example snippet for visual SLAM. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ --map-db-out /path/to/map.msg \ --ros-args -p publish_tf:=false Localization We provide an example snippet for localization based on a prebuilt map. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam \ --disable-mapping \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ --map-db-in /path/to/map.msg \ --ros-args -p publish_tf:=false Offline SLAM We provide an example snippet for localization based on a prebuilt map. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam_offline \ -b /path/to/bagfile.bag2 \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ -o /path/to/map.msg \ --camera=your_camera_topic_namespace \ --storage-id=sqlite3 \ --ros-args -p publish_tf:=false When running colcon build --symlink-install --packages-select stella_vslam_ros, I get the following error colcon build --symlink-install --packages-select stella_vslam_ros Starting >>> stella_vslam_ros --- stderr: stella_vslam_ros /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::compute_orb_descriptor(cv::KeyPoint const&, cv::Mat const&, unsigned char*) const'` /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::ic_angle(cv::Mat const&, cv::Point_<float> const&) const'` /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::orb_impl()'` collect2: error: ld returned 1 exit status gmake[2]: *** [src/CMakeFiles/run_slam.dir/build.make:691: src/run_slam] Error 1 gmake[1]: *** [CMakeFiles/Makefile2:210: src/CMakeFiles/run_slam.dir/all] Error 2 gmake[1]: *** Waiting for unfinished jobs.... /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::compute_orb_descriptor(cv::KeyPoint const&, cv::Mat const&, unsigned char*) const'` /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::ic_angle(cv::Mat const&, cv::Point_<float> const&) const'` /usr/bin/ld: /usr/local/lib/libstella_vslam.so: undefined reference to `stella_vslam::feature::orb_impl::orb_impl()'` collect2: error: ld returned 1 exit status gmake[2]: *** [src/CMakeFiles/run_slam_offline.dir/build.make:691: src/run_slam_offline] Error 1 gmake[1]: *** [CMakeFiles/Makefile2:236: src/CMakeFiles/run_slam_offline.dir/all] Error 2 gmake: *** [Makefile:146: all] Error 2 --- Failed <<< stella_vslam_ros [2.02s, exited with code 2] Summary: 0 packages finished [2.24s] 1 package failed: stella_vslam_ros 1 package had stderr output: stella_vslam_ros

Reasoned for 26 seconds

**Short Answer**  
Those “undefined reference to `orb_impl`” errors happen when the stella_vslam library you installed is missing (or not compiled with) the internal ORB implementation code that stella_vslam_ros expects. In other words, the library exports symbol references to `orb_impl`, but the actual definitions were never compiled into the library.

You can fix this by ensuring that **(1)** you have the correct, up-to-date version of stella_vslam, **(2)** all its submodules are present and up to date, and **(3)** you build it with the proper CMake options so that the `orb_impl` code is included. After that, stella_vslam_ros should link correctly.

Below are the **common causes** of this error, followed by **solutions**.

---

## 1. Common Causes

1. **Old or partial stella_vslam installation**
    
    - Perhaps you installed a previous or partial version into `/usr/local/lib`, and it was never rebuilt with the internal ORB code enabled.
    - Meanwhile, the current stella_vslam_ros code calls those `orb_impl` symbols, causing the linker to fail.
2. **Submodules missing**
    
    - If the stella_vslam repository submodules were not fetched (missing `--recursive` or `git submodule update --init --recursive`), parts of the code (including the `feature/orb_impl` files) might not be built.
3. **CMake option not enabled**
    
    - By default, stella_vslam’s `CMakeLists.txt` has an option `STELLA_VSLAM_USE_ORB_IMPL` that might be turned **off** if certain conditions are met.
    - If it’s off, the compiler skips building the internal ORB code, leading to missing symbols.
4. **Version mismatch**
    
    - If you have stella_vslam from one commit/tag and stella_vslam_ros from a newer commit, there might be code references that do not match.

---

## 2. Step-by-Step Solutions

Here are a few ways to fix the linker problem.

### **Option A: Build stella_vslam directly in your ROS 2 workspace**

1. **Remove old system installs** of stella_vslam to avoid conflicts:
    
    bash
    
    CopyEdit
    
    `sudo rm -f /usr/local/lib/libstella_vslam* sudo rm -rf /usr/local/include/stella_vslam`
    
    (Or at least rename them temporarily if you want to keep backups.)
    
2. **Clone stella_vslam into `~/ros2_ws/src`** (alongside stella_vslam_ros). For example:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws/src git clone --recursive https://github.com/stella-cv/stella_vslam.git`
    
3. **Clone stella_vslam_ros** (ros2 branch) if not already:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws/src git clone --recursive -b ros2 https://github.com/stella-cv/stella_vslam_ros.git`
    
4. **Build** everything with colcon:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws # Make sure to fetch any rosdep dependencies rosdep install -y -i --from-paths src --skip-keys=stella_vslam colcon build --symlink-install source install/setup.bash`
    
5. This approach guarantees that **both** stella_vslam and stella_vslam_ros use consistent code and are compiled with the same flags. You should no longer see missing `orb_impl` symbols.
    

---

### **Option B: Rebuild and install stella_vslam from source (outside workspace), enabling the ORB implementation**

If you really want to install stella_vslam system-wide (like in `/usr/local`) and build stella_vslam_ros in a separate workspace:

1. **Remove any old or conflicting stella_vslam** from `/usr/local`.
    
2. **Clone stella_vslam (with submodules)**:
    
    bash
    
    CopyEdit
    
    `cd ~/lib git clone --recursive https://github.com/stella-cv/stella_vslam.git cd stella_vslam`
    
3. **Configure with internal ORB**  
    You can explicitly enable the internal ORB implementation with:
    
    bash
    
    CopyEdit
    
    `mkdir build && cd build cmake \   -DCMAKE_BUILD_TYPE=RelWithDebInfo \   -DSTELLA_VSLAM_USE_ORB_IMPL=ON \   ..`
    
    _(If for some reason your environment or the stella_vslam CMake defaults do not already enable it.)_
    
4. **Build and install**:
    
    bash
    
    CopyEdit
    
    `make -j$(nproc) sudo make install`
    
5. **Build stella_vslam_ros** in your ROS 2 workspace:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws/src git clone --recursive -b ros2 https://github.com/stella-cv/stella_vslam_ros.git # or pull if you already cloned it  cd ~/ros2_ws colcon build --packages-select stella_vslam_ros --symlink-install source install/setup.bash`
    

This way, the installed `/usr/local/lib/libstella_vslam.so` now includes the `orb_impl` methods, so the linker can resolve those references.

---

### **Option C: Use the official stella_cv instructions carefully**

If you want to follow exactly the instructions from [https://stella-cv.readthedocs.io/en/latest/ros2_package.html](https://stella-cv.readthedocs.io/en/latest/ros2_package.html), be sure to:

1. **Use `git clone --recursive`** for each repo (stella_vslam, stella_vslam_ros, etc.).
2. **Double-check** that the submodules are updated:
    
    bash
    
    CopyEdit
    
    `cd stella_vslam git submodule update --init --recursive`
    
3. **Confirm** that the build logs show the ORB implementation is being compiled.
4. After `sudo make install`, confirm that the installed library in `/usr/local/lib` is the new one (you can check timestamps).

---

## 3. Verify the Fix

- After rebuilding, you can run:
    
    bash
    
    CopyEdit
    
    `ldd /usr/local/lib/libstella_vslam.so | grep orb_impl`
    
    or simply `nm -D /usr/local/lib/libstella_vslam.so | grep orb_impl` to see if those symbols are actually defined in the library.
    
- Then try again:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws colcon build --packages-select stella_vslam_ros --symlink-install`
    
    You should no longer see the undefined reference errors.
    

---

## 4. Summary

You are seeing **undefined reference** errors to `orb_impl` methods because the stella_vslam library you installed does not include those functions. The most likely cause is a mismatch in how (or from which commit) you built stella_vslam, or a missing CMake option that excludes the internal ORB code.  
To solve it:

- **Build stella_vslam and stella_vslam_ros together in the same ROS workspace**, or
- **Rebuild stella_vslam with `-DSTELLA_VSLAM_USE_ORB_IMPL=ON`** (and ensuring all submodules are present).

Either approach ensures that the final `libstella_vslam.so` actually contains the orb_impl symbols that stella_vslam_ros needs. Then the linker error will go away.

o1

##### You said:

I tried the following, with the following results: cmake \ -DCMAKE_BUILD_TYPE=RelWithDebInfo \ -DSTELLA_VSLAM_USE_ORB_IMPL=ON \ .. CMake Deprecation Warning at CMakeLists.txt:14 (cmake_policy): The OLD behavior for policy CMP0074 will be removed from a future version of CMake. The cmake-policies(7) manual explains that the OLD behaviors of all policies are deprecated and that a policy should be set to OLD only under specific short-term circumstances. Projects should be ported to the NEW behavior and not rely on setting a policy to OLD. -- Build type: RelWithDebInfo -- ccache: Disabled -- Address/Memory sanitizer: DISABLED -- Architecture-aware optimization: DISABLED -- Found OpenMP_C: -fopenmp (found version "4.5") -- Found OpenMP_CXX: -fopenmp (found version "4.5") -- Use OpenCV 4.5.4 -- aruco: enabled (Found in /usr/include/opencv4/opencv2) -- Use spdlog on system: 1.9.2 -- gtsam: disabled -- Found AMD library: /usr/lib/x86_64-linux-gnu/libamd.so -- Found AMD header in: /usr/include/suitesparse -- Found CAMD library: /usr/lib/x86_64-linux-gnu/libcamd.so -- Found CAMD header in: /usr/include/suitesparse -- Found COLAMD library: /usr/lib/x86_64-linux-gnu/libcolamd.so -- Found COLAMD header in: /usr/include/suitesparse -- Found CCOLAMD library: /usr/lib/x86_64-linux-gnu/libccolamd.so -- Found CCOLAMD header in: /usr/include/suitesparse -- Found SuiteSparse_config library: /usr/lib/x86_64-linux-gnu/libsuitesparseconfig.so -- Found SuiteSparse_config header in: /usr/include/suitesparse -- Adding librt: /usr/lib/x86_64-linux-gnu/librt.a to SuiteSparse_config libraries (required on Linux & Unix [not OSX] if SuiteSparse is compiled with timing). -- Did not find METIS library (optional SuiteSparse dependency) -- OpenMP: DISABLED -- SSE3 for ORB extraction: DISABLED -- SSE for floating-point operation: DISABLED -- BoW framework: FBoW (found in /usr/local/include) -- trace level log: DISABLED -- Determinism: DISABLED -- tracy: DISABLED -- Configuring done -- Generating done CMake Warning: Manually-specified variables were not used by the project: STELLA_VSLAM_USE_ORB_IMPL -- Build files have been written to: /home/nico/lib/stella_vslam/build

Reasoned for 29 seconds

From the message:

csharp

CopyEdit

`Manually-specified variables were not used by the project:      STELLA_VSLAM_USE_ORB_IMPL`

you can see that the CMake option `STELLA_VSLAM_USE_ORB_IMPL` is **not** recognized by the current version of _stella_vslam_. That variable name appears in older/alternative branches but is no longer valid in the current main branch. Instead, the internal ORB extractor is controlled by a different option—most likely:

nginx

CopyEdit

`STELLA_VSLAM_WITH_ORB_EXTRACTOR`

In other words, if you want to force stella_vslam to build its own internal ORB extractor (the so-called `orb_impl` code), you should specify:

bash

CopyEdit

`cmake \   -DCMAKE_BUILD_TYPE=RelWithDebInfo \   -DSTELLA_VSLAM_WITH_ORB_EXTRACTOR=ON \   ..`

Below is a more detailed explanation and the steps to fix the missing symbol issue (“undefined reference to `orb_impl` …”).

---

## 1. Why `STELLA_VSLAM_USE_ORB_IMPL` Doesn’t Work

- The current CMake code in [stella_vslam’s `master/main` branch](https://github.com/stella-cv/stella_vslam) uses an option called `STELLA_VSLAM_WITH_ORB_EXTRACTOR` (not `STELLA_VSLAM_USE_ORB_IMPL`).
- If you try passing `STELLA_VSLAM_USE_ORB_IMPL=ON`, CMake will ignore it because that variable is never declared or checked anywhere in the newer CMakeLists. Hence the warning about a “Manually-specified variable was not used by the project.”

---

## 2. Correct CMake Option: `STELLA_VSLAM_WITH_ORB_EXTRACTOR`

By default, newer stella_vslam _should_ automatically enable the internal ORB extractor **unless** certain conditions are met (e.g., building with ROCKSDB, or building on an unsupported CPU). To be explicit, you can enable it like so:

bash

CopyEdit

`cd ~/lib/stella_vslam mkdir -p build && cd build cmake \   -DCMAKE_BUILD_TYPE=RelWithDebInfo \   -DSTELLA_VSLAM_WITH_ORB_EXTRACTOR=ON \   .. make -j$(nproc) sudo make install`

You should see in the CMake output something like:

sql

CopyEdit

`-- STELLA_VSLAM_WITH_ORB_EXTRACTOR: ON -- SSE3 for ORB extraction: ENABLED (or something similar, if your CPU supports SSE3) ...`

This indicates the internal ORB code will be compiled into `libstella_vslam.so`. That, in turn, provides the missing symbols that `stella_vslam_ros` expects (the `orb_impl::compute_orb_descriptor` etc.).

---

## 3. Common Pitfalls

1. **Previously installed stella_vslam**  
    If you had an older or partial install in `/usr/local/lib` lacking the ORB extractor, it can conflict. Before rebuilding and installing, remove (or rename) the old library:
    
    bash
    
    CopyEdit
    
    `sudo rm -f /usr/local/lib/libstella_vslam* sudo rm -rf /usr/local/include/stella_vslam`
    
    Then rebuild and install fresh.
    
2. **Cloning without submodules**  
    Make sure you cloned stella_vslam with `--recursive` or ran `git submodule update --init --recursive`. If submodules are missing, some source files (like the ORB extractor code) may not be present.
    
3. **CPU instruction detection**  
    stella_vslam tries to detect SSE, SSE3, etc. automatically. If you’re on x86_64 with a typical CPU, it should enable SSE by default. If not, you can try passing flags like `-DENABLE_SSE3=ON`. However, in most modern Ubuntu x86_64 environments, SSE detection works automatically.
    
4. **Version mismatch**  
    If you have a very old checkout of stella_vslam and a newer stella_vslam_ros, or vice versa, you might get missing symbols. Always ensure both are on compatible branches (e.g., latest `master` for stella_vslam, `ros2` branch for stella_vslam_ros).
    

---

## 4. Recommended Workflow

The simplest method to avoid mismatches is to build _both_ `stella_vslam` and `stella_vslam_ros` inside the **same** ROS 2 workspace using colcon:

bash

CopyEdit

`# 1. Remove old libs from /usr/local (if needed) sudo rm -f /usr/local/lib/libstella_vslam* sudo rm -rf /usr/local/include/stella_vslam  # 2. Create or use an existing ROS 2 workspace mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src  # 3. Clone stella_vslam (with submodules) git clone --recursive https://github.com/stella-cv/stella_vslam.git  # 4. Clone stella_vslam_ros (ros2 branch, with submodules) git clone --recursive -b ros2 https://github.com/stella-cv/stella_vslam_ros.git  # 5. Build everything cd ~/ros2_ws rosdep install --from-paths src --ignore-src -y  # install missing deps colcon build --symlink-install source install/setup.bash`

Now both packages are compiled together. You typically do _not_ need to install stella_vslam system-wide in `/usr/local`, so you avoid version mismatch. The internal orb_impl code should be included automatically (unless disabled in the top-level CMake).

---

## 5. Conclusion

Your error happened because stella_vslam_ros needs the internal ORB code (`orb_impl`), but the stella_vslam library you installed lacked those symbols. The fix is to use the correct CMake option (`STELLA_VSLAM_WITH_ORB_EXTRACTOR=ON`) or simply build stella_vslam within the same colcon workspace, which should enable the internal ORB by default. Once that is done, the “undefined reference to `orb_impl`” linker errors should disappear.

o1

##### You said:

cmake \ -DCMAKE_BUILD_TYPE=RelWithDebInfo \ -DSTELLA_VSLAM_WITH_ORB_EXTRACTOR=ON \ .. CMake Deprecation Warning at CMakeLists.txt:14 (cmake_policy): The OLD behavior for policy CMP0074 will be removed from a future version of CMake. The cmake-policies(7) manual explains that the OLD behaviors of all policies are deprecated and that a policy should be set to OLD only under specific short-term circumstances. Projects should be ported to the NEW behavior and not rely on setting a policy to OLD. -- Build type: RelWithDebInfo -- ccache: Disabled -- Address/Memory sanitizer: DISABLED -- Architecture-aware optimization: DISABLED -- Use OpenCV 4.5.4 -- aruco: enabled (Found in /usr/include/opencv4/opencv2) -- Use spdlog on system: 1.9.2 -- gtsam: disabled -- Found AMD library: /usr/lib/x86_64-linux-gnu/libamd.so -- Found AMD header in: /usr/include/suitesparse -- Found CAMD library: /usr/lib/x86_64-linux-gnu/libcamd.so -- Found CAMD header in: /usr/include/suitesparse -- Found COLAMD library: /usr/lib/x86_64-linux-gnu/libcolamd.so -- Found COLAMD header in: /usr/include/suitesparse -- Found CCOLAMD library: /usr/lib/x86_64-linux-gnu/libccolamd.so -- Found CCOLAMD header in: /usr/include/suitesparse -- Found SuiteSparse_config library: /usr/lib/x86_64-linux-gnu/libsuitesparseconfig.so -- Found SuiteSparse_config header in: /usr/include/suitesparse -- Adding librt: /usr/lib/x86_64-linux-gnu/librt.a to SuiteSparse_config libraries (required on Linux & Unix [not OSX] if SuiteSparse is compiled with timing). -- Did not find METIS library (optional SuiteSparse dependency) -- OpenMP: DISABLED -- SSE3 for ORB extraction: DISABLED -- SSE for floating-point operation: DISABLED -- BoW framework: FBoW (found in /usr/local/include) -- trace level log: DISABLED -- Determinism: DISABLED -- tracy: DISABLED -- Configuring done -- Generating done CMake Warning: Manually-specified variables were not used by the project: STELLA_VSLAM_WITH_ORB_EXTRACTOR -- Build files have been written to: /home/nico/lib/stella_vslam/build

Reasoned for 20 seconds

You are seeing:

csharp

CopyEdit

`Manually-specified variables were not used by the project:      STELLA_VSLAM_WITH_ORB_EXTRACTOR`

because **current stella_vslam no longer uses that CMake option** (nor `STELLA_VSLAM_USE_ORB_IMPL`). In the modern codebase, **the internal ORB extractor is built by default** unless you explicitly switch to an external ORB extractor via a different flag (`STELLA_VSLAM_USE_EXTERNAL_ORB_EXTRACTOR=ON`). The message about “SSE3 for ORB extraction: DISABLED” simply means SSE instructions are not detected or enabled on your system—but it does **not** prevent the internal ORB code (`orb_impl`) from building in a fallback mode.

Below are the key points to get a _fully working_ `libstella_vslam.so` that includes the internal ORB code and avoids the “undefined reference to orb_impl” linker errors in `stella_vslam_ros`.

---

## 1. No Special CMake Option Is Needed

In the main stella_vslam repository, there is **no** `STELLA_VSLAM_WITH_ORB_EXTRACTOR` or `STELLA_VSLAM_USE_ORB_IMPL` option anymore. The internal ORB code is **on** by default unless:

- You turn it off by defining `STELLA_VSLAM_USE_EXTERNAL_ORB_EXTRACTOR=ON`, or
- You are building a very old or different fork/branch of stella_vslam that did use those old flags.

So simply running:

bash

CopyEdit

`cd ~/lib/stella_vslam mkdir build && cd build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j$(nproc) sudo make install`

will compile and install stella_vslam **with** the internal ORB extractor code (the “`orb_impl`” symbols).

---

## 2. Why SSE3 is “DISABLED” (and Does It Matter?)

Your CMake output shows:

sql

CopyEdit

`-- SSE3 for ORB extraction: DISABLED`

This only means the build system either does not detect SSE3 instructions on your CPU (common if you’re on ARM, a VM that hides CPU flags, or certain other architectures), **or** you haven’t enabled architecture-aware compilation. **However**, stella_vslam **still** builds the fallback “pure C++” version of the ORB extractor. You do not need SSE3 for it to work—SSE just gives extra performance.

Hence “DISABLED” **does not** imply that the internal ORB code is missing; it just means the SSE-optimized path is not used.

---

## 3. If You Still Get “Undefined Reference to orb_impl”

If, after building and installing stella_vslam as above, you still see linker errors (e.g. “`undefined reference to 'stella_vslam::feature::orb_impl::...'`”) when building `stella_vslam_ros`, then you likely have **an older installation** of `libstella_vslam.so` somewhere on your system overshadowing the new one. Common culprits:

1. **Old library in `/usr/local/lib`**  
    You may have installed a partial or older stella_vslam that lacked the internal orb_impl. If so, remove or rename it:
    
    bash
    
    CopyEdit
    
    `sudo rm -f /usr/local/lib/libstella_vslam* sudo rm -rf /usr/local/include/stella_vslam`
    
    Then **re-install** your freshly built version.
    
2. **Multiple versions in your `LD_LIBRARY_PATH`**  
    If you have multiple installations or workspace overlays, verify that the right version is being found. You can check with:
    
    bash
    
    CopyEdit
    
    `ldd /path/to/your/run_slam | grep stella_vslam`
    
    or
    
    bash
    
    CopyEdit
    
    `nm -D /usr/local/lib/libstella_vslam.so | grep orb_impl`
    
    which should show the orb_impl symbols in the newly installed library.
    

---

## 4. Easiest Approach: Build Both Packages in One ROS Workspace

To avoid any confusion between old and new libraries, a straightforward method is to build _both_ stella_vslam and stella_vslam_ros together in a **single** ROS 2 workspace:

1. Remove any old stella_vslam in `/usr/local`:
    
    bash
    
    CopyEdit
    
    `sudo rm -f /usr/local/lib/libstella_vslam* sudo rm -rf /usr/local/include/stella_vslam`
    
2. Create (or reuse) `~/ros2_ws`:
    
    bash
    
    CopyEdit
    
    `mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src`
    
3. Clone both repos (with submodules):
    
    bash
    
    CopyEdit
    
    `# stella_vslam git clone --recursive https://github.com/stella-cv/stella_vslam.git # stella_vslam_ros git clone --recursive -b ros2 https://github.com/stella-cv/stella_vslam_ros.git`
    
4. Build them together:
    
    bash
    
    CopyEdit
    
    `cd ~/ros2_ws rosdep install --from-paths src --ignore-src -y colcon build --symlink-install source install/setup.bash`
    

Now `colcon` ensures the same code and correct linking with the internal ORB code. You no longer need to install stella_vslam system-wide.

---

## Summary

- **Ignore** `STELLA_VSLAM_WITH_ORB_EXTRACTOR` or `STELLA_VSLAM_USE_ORB_IMPL`; they are old/unused. The stella_vslam main branch builds its internal ORB by default.
- **SSE3 disabled** simply means no SSE optimizations were detected or enabled. The fallback ORB extractor is still compiled, so functionality is fine.
- **Remove older stella_vslam** libraries if you still get missing symbols. Then build fresh from the latest code.
- **(Recommended)** Build both `stella_vslam` and `stella_vslam_ros` in the same colcon workspace so they are always consistent. This avoids any version mismatch and library conflicts.

Once that’s done, your `stella_vslam_ros` build should succeed without any orb_impl “undefined reference” errors.

o1

##### You said:

I tried 4. Easiest Approach: Build Both Packages in One ROS Workspace. and everything built successfully. now please use the following info from the website, to tell me ho to launch tracking and mapping live from my oak-d pro w camera. I alsready have all the oakd stuff installed. ROS2 Package Installation Prerequisites Tested for Ubuntu 22.04. Please install the following dependencies. ROS2 : humble or later. Please follow Installation of ROS2. image_tools : An optional requirement to use USB cameras. Build Instructions (If using IridescenceViewer) sudo apt install -y libglm-dev libglfw3-dev libpng-dev libjpeg-dev libeigen3-dev libboost-filesystem-dev libboost-program-options-dev git clone https://github.com/koide3/iridescence.git cd iridescence git checkout 085322e0c949f75b67d24d361784e85ad7f197ab git submodule update --init --recursive mkdir -p build cd build cmake \ -DCMAKE_BUILD_TYPE=RelWithDebInfo \ .. make -j$(($(nproc) / 2)) sudo make install (If using PangolinViewer) sudo apt install -y libglew-dev git clone https://github.com/stevenlovegrove/Pangolin.git cd Pangolin git checkout ad8b5f83 sed -i -e "193,198d" ./src/utils/file_utils.cpp mkdir -p build cd build cmake \ -DCMAKE_BUILD_TYPE=Release \ -DBUILD_EXAMPLES=OFF \ -DBUILD_PANGOLIN_DEPTHSENSE=OFF \ -DBUILD_PANGOLIN_FFMPEG=OFF \ -DBUILD_PANGOLIN_LIBDC1394=OFF \ -DBUILD_PANGOLIN_LIBJPEG=OFF \ -DBUILD_PANGOLIN_LIBOPENEXR=OFF \ -DBUILD_PANGOLIN_LIBPNG=OFF \ -DBUILD_PANGOLIN_LIBREALSENSE=OFF \ -DBUILD_PANGOLIN_LIBREALSENSE2=OFF \ -DBUILD_PANGOLIN_LIBTIFF=OFF \ -DBUILD_PANGOLIN_LIBUVC=OFF \ -DBUILD_PANGOLIN_LZ4=OFF \ -DBUILD_PANGOLIN_OPENNI=OFF \ -DBUILD_PANGOLIN_OPENNI2=OFF \ -DBUILD_PANGOLIN_PLEORA=OFF \ -DBUILD_PANGOLIN_PYTHON=OFF \ -DBUILD_PANGOLIN_TELICAM=OFF \ -DBUILD_PANGOLIN_TOON=OFF \ -DBUILD_PANGOLIN_UVC_MEDIAFOUNDATION=OFF \ -DBUILD_PANGOLIN_V4L=OFF \ -DBUILD_PANGOLIN_VIDEO=OFF \ -DBUILD_PANGOLIN_ZSTD=OFF \ -DBUILD_PYPANGOLIN_MODULE=OFF \ .. make -j$(($(nproc) / 2)) make install (If using SocketViewer) sudo apt install -y autogen autoconf libtool cd /tmp git clone https://github.com/shinsumicco/socket.io-client-cpp.git cd socket.io-client-cpp git submodule init git submodule update mkdir build && cd build cmake \ -DCMAKE_BUILD_TYPE=Release \ -DCMAKE_INSTALL_PREFIX=/usr/local \ -DBUILD_UNIT_TESTS=OFF \ .. make -j4 sudo make install sudo apt install -y libprotobuf-dev protobuf-compiler wget -q https://github.com/google/protobuf/archive/v3.6.1.tar.gz tar xf v3.6.1.tar.gz cd protobuf-3.6.1 ./autogen.sh ./configure \ --prefix=/usr/local \ --enable-static=no make -j4 sudo make install rosdep update sudo apt update mkdir -p ~/lib cd ~/lib git clone --recursive --depth 1 https://github.com/stella-cv/stella_vslam.git rosdep install -y -i --from-paths ~/lib cd ~/lib/stella_vslam mkdir -p ~/lib/stella_vslam/build cd ~/lib/stella_vslam/build source /opt/ros/${ROS_DISTRO}/setup.bash cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for IridescenceViewer cd ~/lib git clone --recursive https://github.com/stella-cv/iridescence_viewer.git mkdir -p iridescence_viewer/build cd iridescence_viewer/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for PangolinViewer cd ~/lib git clone --recursive https://github.com/stella-cv/pangolin_viewer.git mkdir -p pangolin_viewer/build cd pangolin_viewer/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install # When building with support for SocketViewer cd ~/lib git clone --recursive https://github.com/stella-cv/socket_publisher.git mkdir -p socket_publisher/build cd socket_publisher/build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .. make -j sudo make install mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src git clone --recursive -b ros2 --depth 1 https://github.com/stella-cv/stella_vslam_ros.git cd ~/ros2_ws rosdep install -y -i --from-paths ~/ros2_ws/src --skip-keys=stella_vslam colcon build --symlink-install For using USB cam as a image source, download a repository of demos and pick image_tools module. cd ~/ros2_ws git clone https://github.com/ros2/demos.git cp -r demos/image_tools src/ rm -rf demos Examples Publisher Publish Images by a video ros2 run image_publisher image_publisher_node ./aist_living_lab_1/video.mp4 --ros-args --remap /image_raw:=/camera/image_raw Publish Images Captured by a USB Camera For using a standard USB camera for visual SLAM or localization. ros2 run image_tools cam2image Republish the ROS topic to /camera/image_raw. ros2 run image_transport republish \ raw in:=image raw out:=/camera/image_raw Subscriber Subscribers continually receive images. Please execute one of the following command snippets in the new terminal. Note Option arguments are the same as the examples of stella_vslam. Tracking and Mapping We provide an example snippet for visual SLAM. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ --map-db-out /path/to/map.msg \ --ros-args -p publish_tf:=false Localization We provide an example snippet for localization based on a prebuilt map. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam \ --disable-mapping \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ --map-db-in /path/to/map.msg \ --ros-args -p publish_tf:=false Offline SLAM We provide an example snippet for localization based on a prebuilt map. The source code is placed at stella_vslam_ros/src/run_slam.cc. source ~/ros2_ws/install/setup.bash ros2 run stella_vslam_ros run_slam_offline \ -b /path/to/bagfile.bag2 \ -v /path/to/orb_vocab.fbow \ -c /path/to/config.yaml \ -o /path/to/map.msg \ --camera=your_camera_topic_namespace \ --storage-id=sqlite3 \ --ros-args -p publish_tf:=false

Reasoned for 13 seconds

Below is a concise set of steps to run **stella_vslam** tracking + mapping **live** from your OAK-D Pro camera in ROS 2, using the `run_slam` executable provided by `stella_vslam_ros`. We assume:

- You’ve already built both `stella_vslam` and `stella_vslam_ros` in your `~/ros2_ws` (using the “Easiest Approach” so there’s no library conflict).
- You have a working OAK-D Pro ROS driver installed (e.g., [depthai-ros-driver](https://github.com/luxonis/depthai-ros) or a similar package), which publishes camera images and info topics.
- You have (or will create) a **camera config** YAML file appropriate for the OAK-D Pro (i.e., correct intrinsics, resolution, etc.).
- You already downloaded an ORB vocabulary file (e.g., `.fbow` or `.dbow2`) for place recognition.

---

## 1. Launch Your OAK-D Pro Camera Node

Open one terminal, source your ROS 2 workspace, and launch the OAK-D Pro driver. The exact command depends on which driver you use, but for example:

bash

CopyEdit

`# Terminal 1 source ~/ros2_ws/install/setup.bash ros2 launch depthai_ros_driver oak_d_camera.launch.py`

(Or any other method that starts up the node which publishes `/oak/rgb/image_raw`, `/oak/rgb/camera_info`, etc. Check your driver’s documentation to confirm the topic names.)

Verify the camera is publishing by running:

bash

CopyEdit

`ros2 topic list # or ros2 topic echo /oak/rgb/image_raw`

---

## 2. Prepare a Camera Config YAML (for stella_vslam)

You need a config file telling stella_vslam the camera parameters. A typical file might look like:

yaml

CopyEdit

`Camera:   name: OAKD_Pro   setup: monocular       # or stereo, rgbd, etc., depending on your usage   fps: 30   cols: 1280   rows: 720   fx: 620.0   fy: 620.0   cx: 640.0   cy: 360.0   # Distortion coefficients, etc.  Feature:   type: ORB   max_num_keypoints: 1000   scale_factor: 1.2   num_levels: 8   ini_fast_threshold: 20   min_fast_threshold: 7`

- Adapt the numerical values to your exact OAK-D Pro intrinsics/resolution.
- You can find example configs in `stella_vslam/example` or the stella_vslam_ros repo and tweak them for the OAK-D Pro.

---

## 3. Run Live Tracking + Mapping with `run_slam`

In a **second terminal** (with your workspace sourced), run the stella_vslam ROS node:

bash

CopyEdit

`# Terminal 2 source ~/ros2_ws/install/setup.bash  ros2 run stella_vslam_ros run_slam \     -v /path/to/orb_vocab.fbow \               # ORB vocabulary file     -c /path/to/oakd_config.yaml \             # Your camera config     --map-db-out /tmp/map.msg \                # Output map file (optional)     --ros-args \       -p publish_tf:=false \                   # or true if you want TF       -r /camera/image_raw:=/oak/rgb/image_raw \       -r /camera/camera_info:=/oak/rgb/camera_info`

**Notes:**

1. **Vocabulary**: Replace `/path/to/orb_vocab.fbow` with the actual path to your ORB vocabulary file (FBOW, DBOW2, etc.).
2. **Config**: Replace `/path/to/oakd_config.yaml` with the real path to your custom camera config.
3. **Remapping**: The above remaps stella_vslam’s default topics (`/camera/image_raw`, `/camera/camera_info`) to whatever your OAK-D driver uses (`/oak/rgb/image_raw`, `/oak/rgb/camera_info`).
4. **publish_tf**: Set to `true` if you want stella_vslam to broadcast TF transforms of the camera pose. (If you’re not sure, start with `true`; or leave `false` if you already have some transform tree you prefer to manage.)

---

## 4. (Optional) Enabling a Viewer

- If you installed **Pangolin** or **IridescenceViewer**, you can enable them in one of two ways:
    1. **Parameter** (e.g., `-p enable_pangolin_viewer:=true`), if the stella_vslam build supports it.
    2. **Separate** viewer packages (e.g., `pangolin_viewer` or `iridescence_viewer`) which connect automatically to the stella_vslam node.

For instance, you might add:

bash

CopyEdit

`--ros-args -p enable_pangolin_viewer:=true`

to the `run_slam` command if your stella_vslam build has Pangolin support and the parameter is recognized.

---

## 5. Watch It Work

Once you run `run_slam`, you should see console logs indicating that frames are being received and processed. If a viewer is enabled, a visualization window will pop up showing keypoints and the map being built.

You now have **live tracking and mapping** from your OAK-D Pro camera in stella_vslam.

---

### Quick Recap

1. **Terminal 1**: Launch OAK-D Pro driver
    
    bash
    
    CopyEdit
    
    `ros2 launch depthai_ros_driver oak_d_camera.launch.py`
    
2. **Terminal 2**: Launch stella_vslam ROS node
    
    bash
    
    CopyEdit
    
    `ros2 run stella_vslam_ros run_slam \     -v /path/to/orb_vocab.fbow \     -c /path/to/oakd_config.yaml \     --map-db-out /tmp/map.msg \     --ros-args \       -r /camera/image_raw:=/oak/rgb/image_raw \       -r /camera/camera_info:=/oak/rgb/camera_info`
    
3. (Optional) Tweak parameters, watchers, or viewers as desired.

That’s it—your camera images will feed into stella_vslam’s SLAM pipeline, building a map in real time.








# 2. OK, now better

After struggling through installation with ChatGPT, I did following:

1. oakdprow_cam_config.yaml in /home/nico/ros2_ws/src/stella_vslam_ros/config
```Shell
ros2 launch depthai_ros_driver pointcloud.launch.py
#OR
ros2 launch depthai_examples rgb_stereo_node.launch.py previewWidth:=1280 previewHeight:=720 usePreview:=True dotProjectorIntensity:=150.0
```
1. fbow file can be found on [this website](https://stella-cv.readthedocs.io/en/latest/example.html#chapter-example) 

```Shell
source ~/ros2_ws/install/setup.bash

# Example command:
ros2 run stella_vslam_ros run_slam \

    -v /home/nico/ros2_ws/src/stella_vslam_ros/config/orb_vocab.fbow \
    -c /home/nico/ros2_ws/src/stella_vslam_ros/config/oakdprowRGBD_mono_cam_config.yaml \
    --map-db-out /home/nico/Desktop/map.msg \
    --ros-args \
      -p publish_tf:=true \
      -r /camera/image_raw:=/oak/rgb/image_raw \
      -r /camera/camera_info:=/oak/rgb/camera_info

```

colcon build --packages-select stella_vslam stella_vslam_ros                 
source install/setup.bash

```Shell

source ~/ros2_ws/install/setup.bash

# Example command for rgb monocular:
ros2 run stella_vslam_ros run_slam \
	--disable-mapping \
    -v /home/nico/ros2_ws/src/stella_vslam_ros/config/orb_vocab.fbow \
    -c /home/nico/ros2_ws/src/stella_vslam_ros/config/oakdprowRGBD_mono_cam_config.yaml \
    --map-db-out /home/nico/Desktop/map.msg \
    --ros-args \
      -p publish_tf:=true \
      -p odom_frame_id:=map \
      -p base_link_frame_id:=oak_right_camera_optical_frame\
      -p enable_iridescence_viewer:=true \
      -r /camera/image_raw:=/oak/rgb/image_raw \
      -r /camera/camera_info:=/oak/rgb/camera_info

```

```Shell
source ~/ros2_ws/install/setup.bash

# Example command for rgb monocular:
ros2 run stella_vslam_ros run_slam \
    -v /home/nico/ros2_ws/src/stella_vslam_ros/config/orb_vocab.fbow \
    -c /home/nico/ros2_ws/src/stella_vslam_ros/config/oakdprowRGBD_mono_cam_config.yaml \
    --map-db-out /home/nico/Desktop/map.msg \
    --ros-args \
      -p enable_iridescence_viewer:=true \
      -r /camera/image_raw:=/oak/rgb/image_raw \
      -r /camera/camera_info:=/oak/rgb/camera_info

```

```Shell
source ~/ros2_ws/install/setup.bash

# Example command for stereo:
ros2 run stella_vslam_ros run_slam \
    -v /home/nico/ros2_ws/src/stella_vslam_ros/config/orb_vocab.fbow \
    -c /home/nico/ros2_ws/src/stella_vslam_ros/config/oakdprow_stereo_cam_config.yaml \
    --map-db-out /home/nico/Desktop/map.msg \
    --ros-args \
      -p enable_iridescence_viewer:=true \
      -r /camera/image_raw:=/oak/stereo/image_raw \
      -r /camera/camera_info:=/oak/stereo/camera_info
```






